using TradeBase.Core.Models;

namespace TradeBase.Core.Interfaces;

/// <summary>
/// Interface for all trading strategies
/// </summary>
public interface ITradingStrategy
{
    string Name { get; }
    string Description { get; }
    bool IsActive { get; }
    StrategyState State { get; }
    
    // Events
    event EventHandler<SignalEventArgs>? SignalGenerated;
    event EventHandler<StrategyErrorEventArgs>? ErrorOccurred;
    
    // Lifecycle
    Task<bool> InitializeAsync(StrategyConfiguration config, CancellationToken cancellationToken = default);
    Task<bool> StartAsync(CancellationToken cancellationToken = default);
    Task<bool> StopAsync(CancellationToken cancellationToken = default);
    
    // Configuration
    Task<bool> UpdateConfigurationAsync(StrategyConfiguration config, CancellationToken cancellationToken = default);
    StrategyConfiguration GetCurrentConfiguration();
    
    // Performance
    StrategyPerformance GetPerformanceMetrics();
}

/// <summary>
/// Interface for fully automated (hands-free) strategies
/// </summary>
public interface IFullyAutomatedStrategy : ITradingStrategy
{
    // Automated decision making
    Task<TradeSignal?> EvaluateEntryAsync(MarketContext context, CancellationToken cancellationToken = default);
    Task<TradeSignal?> EvaluateExitAsync(Position position, MarketContext context, CancellationToken cancellationToken = default);
    Task<PositionScaleSignal?> EvaluateScaleInAsync(Position position, MarketContext context, CancellationToken cancellationToken = default);
    Task<PositionScaleSignal?> EvaluateScaleOutAsync(Position position, MarketContext context, CancellationToken cancellationToken = default);
    
    // Risk validation
    bool ValidateRisk(Position proposedPosition, AccountInfo account);
}

/// <summary>
/// Strategy configuration
/// </summary>
public class StrategyConfiguration
{
    public string StrategyId { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Symbol { get; set; } = "ES";
    public string Account { get; set; } = "Sim101";
    public TradingMode Mode { get; set; } = TradingMode.Paper;
    
    // Entry criteria
    public double EntryConfidenceThreshold { get; set; } = 0.65;
    public double ExitConfidenceThreshold { get; set; } = 0.55;
    
    // Risk management
    public double RiskPerTradePercent { get; set; } = 1.0;  // 1% of account
    public double MaxDailyLossPercent { get; set; } = 3.0;  // 3% daily limit
    public int MaxConcurrentPositions { get; set; } = 3;
    
    // Position sizing
    public bool EnablePyramiding { get; set; } = true;
    public int MaxPyramidLevels { get; set; } = 3;
    public double PyramidThreshold { get; set; } = 1.0;  // ATR multiple
    
    // Exits
    public double StopLossATR { get; set; } = 1.5;
    public double TakeProfitATR { get; set; } = 3.0;
    public bool UseTrailingStop { get; set; } = true;
    public double TrailingStopATR { get; set; } = 1.0;
    public bool MoveToBreakeven { get; set; } = true;
    public double BreakevenTriggerATR { get; set; } = 1.0;
}

/// <summary>
/// Strategy state
/// </summary>
public enum StrategyState
{
    Uninitialized,
    Initializing,
    Ready,
    Running,
    Paused,
    Stopping,
    Stopped,
    Error
}

/// <summary>
/// Trade signal type
/// </summary>
public enum SignalType
{
    EntryLong,
    EntryShort,
    Exit,
    ScaleIn,
    ScaleOut,
    MoveStop,
    Cancel
}

/// <summary>
/// Trade signal generated by strategy
/// </summary>
public class TradeSignal
{
    public string SignalId { get; set; } = Guid.NewGuid().ToString();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string Symbol { get; set; } = string.Empty;
    public SignalType Type { get; set; }
    public OrderAction Action { get; set; }
    public int Quantity { get; set; }
    public double? LimitPrice { get; set; }
    public double? StopPrice { get; set; }
    public double Confidence { get; set; }  // 0.0 to 1.0
    public string? Reason { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}

/// <summary>
/// Position scaling signal
/// </summary>
public class PositionScaleSignal
{
    public string SignalId { get; set; } = Guid.NewGuid().ToString();
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string Symbol { get; set; } = string.Empty;
    public int AdditionalQuantity { get; set; }  // Positive for scale in, negative for scale out
    public double Confidence { get; set; }
    public string? Reason { get; set; }
}

/// <summary>
/// Market context for decision making
/// </summary>
public class MarketContext
{
    public string Symbol { get; set; } = string.Empty;
    public double CurrentPrice { get; set; }
    public double ATR { get; set; }  // Average True Range
    public double DailyVolume { get; set; }
    public List<BarUpdate> RecentBars { get; set; } = new();
    public PriceUpdate? LatestTick { get; set; }
    public MarketRegime Regime { get; set; } = MarketRegime.Unknown;
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    
    // AI predictions (placeholder for now)
    public double? DirectionConfidence { get; set; }  // -1.0 to 1.0 (short to long)
    public double? VolatilityPrediction { get; set; }
}

/// <summary>
/// Market regime classification
/// </summary>
public enum MarketRegime
{
    Unknown,
    TrendingUp,
    TrendingDown,
    Ranging,
    Volatile,
    Choppy
}

/// <summary>
/// Strategy performance metrics
/// </summary>
public class StrategyPerformance
{
    public DateTime PeriodStart { get; set; }
    public DateTime PeriodEnd { get; set; }
    public int TotalTrades { get; set; }
    public int WinningTrades { get; set; }
    public int LosingTrades { get; set; }
    public double WinRate => TotalTrades > 0 ? (double)WinningTrades / TotalTrades : 0;
    public double TotalPnL { get; set; }
    public double AverageWin { get; set; }
    public double AverageLoss { get; set; }
    public double ProfitFactor => AverageLoss != 0 ? Math.Abs(AverageWin / AverageLoss) : 0;
    public double MaxDrawdown { get; set; }
    public double SharpeRatio { get; set; }
    public int ConsecutiveWins { get; set; }
    public int ConsecutiveLosses { get; set; }
}

// Event args
public class SignalEventArgs : EventArgs
{
    public required TradeSignal Signal { get; set; }
}

public class StrategyErrorEventArgs : EventArgs
{
    public required string Error { get; set; }
    public Exception? Exception { get; set; }
    public bool IsFatal { get; set; } = false;
}
